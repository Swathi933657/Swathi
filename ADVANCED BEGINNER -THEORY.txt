1.What is FASTAPI  and why is it popular?
ANS:FastAPI is a modern Python framework used to build APIs (web applications) quickly and efficiently.
It is based on Python 3.6+, and uses ASGI (Asynchronous Server Gateway Interface).
It is mainly used for:
âœ”ï¸ Building REST APIs
âœ”ï¸ Handling HTTP requests (GET, POST, PUT, DELETE)
âœ”ï¸ Fast backend development.
FastAPI Popular:
| Reason                       | Explanation                                                                  |
| ---------------------------- | ---------------------------------------------------------------------------- |
| âš¡ **Very Fast**              | It is one of the fastest Python frameworks â€“ close to Node.js & Go in speed. |
| ğŸ§  **Easy to Learn**         | Simple and clean code â€“ perfect for beginners and professionals.             |
| ğŸ” **Asynchronous**          | Supports async programming (better performance).                             |
| ğŸ§¾ **Automatic Docs**        | Gives API documentation automatically using Swagger UI and ReDoc.            |
| ğŸ›¡ï¸ **Type Hinting Support** | Uses Python type hints to catch errors early.                                |
| ğŸ“¦ **Used in Production**    | Big companies like Uber, Microsoft, Netflix use it.                          |

Example:
from fastapi import FastAPI

app = FastAPI()

@app.get("/")   # GET request
def home():
    return {"message": "Welcome to FastAPI!"}


2.What is Difference between FastAPI and Flask?
ANS:FastAPI vs Flask:
| Feature                  | **FastAPI**                            | **Flask**                     |
| ------------------------ | -------------------------------------- | ----------------------------- |
| **Speed**                | ğŸš€ Very fast (supports async)          | ğŸ¢ Slower compared to FastAPI |
| **Type Checking**        | âœ” Uses Python type hints (less errors) | âŒ No built-in type checking   |
| **Automatic API Docs**   | âœ” YES (Swagger & ReDoc)                | âŒ NO (needs extra packages)   |
| **Asynchronous Support** | âœ” Built-in async/await support         | âŒ Not built-in                |
| **Learning Curve**       | ğŸ§  Easy and modern                     | ğŸ˜Š Very easy, simple          |
| **Best For**             | APIs, ML models, production apps       | Small apps, beginners         |
| **Used By**              | Uber, Netflix, Microsoft               | Pinterest, Mozilla            |

Flask:
Older framework (released in 2010)
Good for simple projects
Requires extra libraries for authentication, database, validation, etc.
Does not support async natively

CODE:

from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello from Flask!"

FastAPI:
New (released in 2018)
Designed for fast performance and APIs
Automatically creates API documentation
Supports async / await (better for real-time apps)

CODE:
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def home():
    return {"message": "Hello from FastAPI!"}



3.What is ASGI and WSGI?
ANS:WSGI:
WSGI is the older Python standard.
Works only with synchronous (one-by-one) requests.
Good for simple web pages.
Not good for live chat, notifications, video calls, real-time apps.

ğŸ‘‰ Used in : Flask, old Django, Pyramid, Bottle
client â†’ Request â†’ WSGI â†’ Response â†’ Client

 ASGI:
ASGI is the modern version of WSGI.
Supports asynchronous requests (multiple at a time)
Better for real-time apps like chat, streaming, games
Can handle WebSockets

ğŸ‘‰ Used in : FastAPI, Django (3.0+), Starlette

Multiple Clients â†’ ASGI â†’ Fast & Real-time Responses

ğŸ§¾ Diagram
WSGI (Old Way)      â†’  One request at a time â³  
ASGI (New Way)      â†’  Handles many requests at once âš¡

WSGI vs ASGI:
| Feature        | **WSGI**                          | **ASGI**                                     |
| -------------- | --------------------------------- | -------------------------------------------- |
| Full Form      | Web Server Gateway Interface      | Asynchronous Server Gateway Interface        |
| Type           | Synchronous (1 request at a time) | Asynchronous (handles many requests at once) |
| Speed          | Slower                            | Faster                                       |
| Real-time apps | âŒ Not suitable                    | âœ” Supports real-time apps                    |
| Best For       | Old/traditional web apps          | Modern, fast APIs & web apps                 |
| Used In        | Flask, Django (old versions)      | FastAPI, Django (new versions)               |



4.What is pydantic's role in FastAPI?
ANS:Pydantic is a Python library used for:
âœ”ï¸ Data validation
âœ”ï¸ Data parsing
âœ”ï¸ Type checking
It helps ensure that incoming data (like API requests) is correct and safe.

Pydanticâ€™s Role in FastAPI:
| Purpose               | What Pydantic Does                                                    |
| --------------------- | --------------------------------------------------------------------- |
| ğŸ“ Validate data      | Checks if the data is correct (e.g., email format, integer vs string) |
| ğŸ“¦ Create data models | Defines request & response structures                                 |
| ğŸ›¡ï¸ Prevent errors    | Catches wrong input before it breaks code                             |
| ğŸ“„ API docs           | Helps FastAPI generate clear documentation automatically              |


5.What is Dependency injection?
ANS: Dependency Injection (DI) means giving the required tools (dependencies) to a function or class instead of creating them inside it.
ğŸ‘‰ It helps to reuse code, write cleaner programs, and test easily.

Without DI:
def get_data():
    db = Database()  # created inside function
    return db.fetch()
âš  Problem: If we want to use another database, testing becomes difficult because the database is fixed inside the function.

With Dependency Injection:
def get_data(db: Database):  # Dependency is passed to the function
    return db.fetch()

Now we can easily change or replace the database:

python
Copy code
db = Database()
get_data(db)   # easy and flexible

Dependency Injection useful:
âœ” Makes code reusable
âœ” Easy to test
âœ” Reduces errors
âœ” Cleaner & more organized code
âœ” We can replace parts easily (plug-and-play)

Dependency Injection in FastAPI:
FastAPI supports DI automatically using the Depends() function.

EXAMPLE:
from fastapi import FastAPI, Depends

app = FastAPI()

# Dependency function
def get_db():
    return "Database Connected"

@app.get("/items/")
def read_items(db=Depends(get_db)):
    return {"message": db}

Conclusion:

Dependency Injection = Giving tools instead of creating them.
It helps write clean, flexible, and testable code.
FastAPI makes DI very easy using Depends().

ADVANCED BEGINNER- THEORY:
11.Response models?
ANS:In FastAPI, response models are used to control what data is sent back to the user from an API endpoint.
They help to:
âœ”ï¸ Validate the output
âœ”ï¸ Hide sensitive data
âœ”ï¸ Ensure correct data format
âœ”ï¸ Improve documentation (Swagger UI)

create response models using Pydantic.

 Response Models Are Useful:
Imagine your database returns all user details (including password).
But you want to show only name & email â€” NOT password.
â¡ï¸ Response models help to send only required data.

Example â€“ Without Response Model:
from fastapi import FastAPI

app = FastAPI()

@app.get("/user")
def get_user():
    return {"name": "Swathi", "email": "swathi@example.com", "password": "12345"}
-ğŸ‘‰ This returns the password also âŒ (not safe).

Using Response Model (Correct Way):
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

# Response Model â€“ What we want to show
class UserResponse(BaseModel):
    name: str
    email: str

@app.get("/user", response_model=UserResponse)
def get_user():
    return {"name": "Swathi", "email": "swathi@example.com", "password": "12345"}
OUTPUT:
{
  "name": "Swathi",
  "email": "swathi@example.com"
}
âœ”ï¸ Password is hidden automatically! 

Final Summary:
âœ” Response models make APIs safe and clean
âœ” Use Pydantic BaseModel
âœ” Use response_model=YourModel in endpoint
âœ” Automatically hides unwanted data


12.Status codes?
ANS:A status code is a 3-digit number sent by the server in response to a client's request (like when you open a website or use an API).
It tells whether the request was successful, failed, redirected, or had an error.
Status Code Categories:
| Category | Range   | Meaning                          |
| -------- | ------- | -------------------------------- |
| **1xx**  | 100â€“199 | Informational (request received) |
| **2xx**  | 200â€“299 | Success                          |
| **3xx**  | 300â€“399 | Redirection                      |
| **4xx**  | 400â€“499 | Client error                     |
| **5xx**  | 500â€“599 | Server error                     |
Common Status Codes:
| Code                          | Meaning                       |
| ----------------------------- | ----------------------------- |
| **200 OK**                    | Request successful            |
| **201 Created**               | New resource created          |
| **204 No Content**            | Success but no data to return |
| **301 Moved Permanently**     | Redirected to a new URL       |
| **302 Found**                 | Temporary redirect            |
| **400 Bad Request**           | Wrong data sent by client     |
| **401 Unauthorized**          | Login required                |
| **403 Forbidden**             | Access denied                 |
| **404 Not Found**             | URL/Resource not found        |
| **500 Internal Server Error** | Server crashed                |
| **503 Service Unavailable**   | Server is down or overloaded  |
Example in FastAPI:
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/hello")
def say_hello():
    return {"message": "Hello!"}  # Status code 200 by default

@app.get("/not_found")
def not_found():
    raise HTTPException(status_code=404, detail="Item not found")

13.Query vs Path parameters?
ANS:Path Parameters:
Used to identify a specific resource.
They are part of the URL path.
Mandatory (required)
Written inside { } in FastAPI

ğŸ“Œ Example URL:
https://api.com/users/10
Here, 10 is a path parameter â†’ user with ID 10.

Query Parameters
Used to filter, search, or sort data.
Written after ? in the URL.
They are optional.
You can send multiple query parameters using &.

ğŸ” Example URL:
https://api.com/users?age=20&country=india

age=20 â†’ Query parameter
country=india â†’ Query parameter

FastAPI Example:
from fastapi import FastAPI

app = FastAPI()

@app.get("/users")
def filter_users(age: int = None, country: str = None):
    return {"age": age, "country": country}

Difference Table:
| Feature     | Path Parameter    | Query Parameter  |
| ----------- | ----------------- | ---------------- |
| Position    | In URL path       | After `?` symbol |
| Required    | Yes               | No (optional)    |
| Purpose     | Identify resource | Filter or search |
| Example URL | `/users/10`       | `/users?age=20`  |


14.HTTPExeception usage?
ANS:HTTPException is used in FastAPI when you want to send an error response to the client with a custom status code and message.

use HTTPException:
To return an error properly
To send custom status code (like 404, 400, 401â€¦)
To send error message
Helps in API validation

Import & Basic Usage:
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/items/{item_id}")
def get_item(item_id: int):
    if item_id != 1:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item_id": item_id, "name": "Laptop"}

Common Use Cases of HTTPException:
| Use Case           | Status Code | Example Situation    |
| ------------------ | ----------- | -------------------- |
| Resource not found | 404         | Item/User not found  |
| Bad request        | 400         | Invalid data         |
| Unauthorized       | 401         | Login required       |
| Forbidden          | 403         | Access not allowed   |
| Server error       | 500         | Something went wrong |


15.Middleware
ANS:Middleware is a function that runs before and/or after every request in FastAPI.

It is used to:
âœ” Log requests
âœ” Measure response time
âœ” Check authentication
âœ” Modify request or response
âœ” Add headers automatically
Middleware Works:
Client  â†’  Middleware  â†’  Endpoint  â†’  Middleware  â†’  Response

Creating Middleware in FastAPI:
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")   # <-- Middleware
async def log_requests(request: Request, call_next):
    print(f"Request URL: {request.url}")  # Before request

    response = await call_next(request)   # Call API endpoint

    print("Request Completed")  # After response
    return response

Folder Structure Example:
project/
â”‚â”€â”€ main.py
â”‚â”€â”€ middlewares/
â”‚     â””â”€â”€ auth_middleware.py



